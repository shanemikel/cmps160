/*
 *   COPYRIGHT: Shane Pearlman 2018
 */

#include "shapes.jsc"
#include "collections.jsc"
#include "util.jsc"

let WHITE          = null;
let BLACK          = null;
let RED            = null;
let GREEN          = null;
let BLUE           = null;
let GREY           = null;
let DARK_GREY      = null;
let LIGHT_GREY     = null;

let CANVAS         = null;
let WIDTH          = null;
let HEIGHT         = null;
let DEPTH          = 250;
let COLOR          = null;

let ROTATE_X       = 0;
let ROTATE_Y       = 0;
let ROTATE_Z       = 0;

let TRANSLATE_X    = 0;
let TRANSLATE_Y    = 0;
let TRANSLATE_Z    = 0;

let MODELS         = null;

let SELECTED       = null;
let FOCUSED        = null;

let CAMERA;
{
    let EYE        = new Vector(0, 0, 400);
    let FRONT      = ORIGIN.sub(EYE);
    let UP         = new Vector(0, 1,   0);
    CAMERA         = new Camera(EYE, FRONT, UP);
}

let AMBIANT_COLOR  = TRUE_WHITE.scale(0.1);

let DIRECT_X       = 0;
let DIRECT_Y       = -100;
let DIRECT_Z       = -100;
let DIRECT_COLOR   = TRUE_WHITE.scale(0.6);

let SHOW_POINT     = true;

let POINT_X        = 150;
let POINT_Y        = 50;
let POINT_Z        = 80;
let POINT_COLOR    = TRUE_WHITE;

let SPECULAR_POWER = 64;

let TABS           = [];
let TAB_COUNTER    = 0;

let light = {
    AMBIANT:  'light-ambiant',
    DIRECT:   'light-direct',
    POINT:    'light-point',
    SPECULAR: 'light-specular'
};
let LIGHT = {
    ambiant:  true,
    direct:   false,
    point:    true,
    specular: true
};

let PERSPECTIVE_FOVY = 60;

let projection = {
    ORTHOGRAPHIC: 'projection-orthographic',
    PERSPECTIVE:  'projection-perspective'
};
let PROJECTION = projection.PERSPECTIVE;

let shading = {
    MODEL:          'shading-model',
    FLAT:           'shading-flat',
    GOURAUD:        'shading-gouraud',
    PHONG:          'shading-phong',
    NORMAL:         'shading-normal',
    DEPTH:          'shading-depth',
    EDGE:           'shading-edge',
    EDGE_SELECTION: 'shading-edge-selection',
    RED_CYAN:       'shading-red-cyan'
};
let SHADING = shading.MODEL;

let shape = {
    CYLINDER: 'shape-cylinder',
    SPHERE:   'shape-sphere'
};
let SHAPE = shape.SPHERE;

let KEYS = {
    y:     89,
    u:     85,

    g:     71,
    h:     72,

    i:     73,
    o:     79,

    j:     74,
    k:     75,
    
    LEFT:  37,
    RIGHT: 39,

    UP:    38,
    DOWN:  40
};

let RKEYS = {};


function init() {
    LOAD_CSS_COLOR(WHITE      , '--white')
    LOAD_CSS_COLOR(BLACK      , '--black')
    LOAD_CSS_COLOR(RED        , '--red')
    LOAD_CSS_COLOR(GREEN      , '--green')
    LOAD_CSS_COLOR(BLUE       , '--blue')
    LOAD_CSS_COLOR(GREY       , '--grey')
    LOAD_CSS_COLOR(DARK_GREY  , '--dark-grey')
    LOAD_CSS_COLOR(LIGHT_GREY , '--light-grey')

    WIDTH  = $('#g-webgl').css('width');
    HEIGHT = $('#g-webgl').css('height');
    COLOR  = RGBColor.fromHex($('#g-webgl').css('--background-color'));

    CANVAS = $('#webgl');
    CANVAS.attr('width'  , WIDTH);
    CANVAS.attr('height' , HEIGHT);

    $('span.spacer').each(function(i, elem) {
        let e = $(elem);
        e.css('width', e.attr('data-size') || e.css('--size'));
    });

    $('.tab-labels').each(function(i, elem) {
        let e  = $(elem);
        let id = TAB_COUNTER++;

        e.attr('data-id', id);
        TABS[id] = [];

        let def = e.attr('data-default') || e.children('label').first().attr('for');
        set_current_tab(elem, def);

        e.children('label').each(function(i, elem) {
            if ($(elem).attr('data-disabled') !== 'disabled')
                TABS[id].push(`label[for=${$(elem).attr('for')}]`);
        });

        enable_tabs(e);
    });

    Object.keys(KEYS).forEach((k) => RKEYS[KEYS[k]] = k);

    setupIOSOR('file-picker');
}

function enable_tabs(e) {
    if (e === undefined) {
        $('.tab-labels').each((i, elem) => enable_tabs(elem));
        return;
    }

    e = $(e);

    let id = e.attr('data-id');
    TABS[id].map(function(elem) {
        $(elem).removeAttr('data-disabled');
    });

    e.children('label').each(function(i, elem) {
        let label_for = $(elem).attr('for');
        $(elem).click(function(ev) {
            if ($(ev.target).attr('data-disabled') !== 'disabled')
                set_current_tab(e, label_for)
        });
    });
}

function disable_tabs(e) {
    if (e === undefined) {
        $('.tab-labels').each((i, elem) => disable_tabs(elem));
        return;
    }

    e = $(e);

    let id = e.attr('data-id');
    TABS[id].map(function(elem) {
        $(elem).attr('data-disabled', 'disabled');
    });

    e.children('label').each(function(i, elem) {
        $(elem).off('click');
    });
}

function set_current_tab(tabs_elem, label_for) {
    $(tabs_elem).children('label').each(function(i, elem) {
        let e = $(elem);
        if (e.attr('for') !== label_for)
            e.removeClass('current');
        else
            e.addClass('current');
    });

    $(tabs_elem).nextAll('.tab').each(function(i, elem) {
        let e = $(elem);
        if (e.attr('id') !== label_for)
            e.prop('hidden', true);
        else
            e.prop('hidden', false);
    });
}

function begin_animation(buttonID) {
    disable_tabs();
    $('#animation button').each(function(i, elem) {
        if (buttonID !== undefined) {
            if ($(elem).attr('id') === buttonID)
                $(elem).addClass('running');
            else
                $(elem).prop('disabled', true);
        } else {
            $(elem).prop('disabled', true);
        }
    });
}

function end_animation(buttonID) {
    $('#animation button').each(function(i, elem) {
        if (buttonID !== undefined) {
            if ($(elem).attr('id') === buttonID)
                $(elem).removeClass('running');
            else
                $(elem).prop('disabled', false);
        } else {
            $(elem).prop('disabled', false);
        }
    });
    enable_tabs();
}


function main() {
    init();

    let gl = getWebGLContext(CANVAS[0]);
    if (! gl) {
        log('Failed to get the rendering context for WebGL');
        return;
    }

    start(gl);
}

function start(gl) {
    gl.enable(gl.DEPTH_TEST);

    let width  = parseInt(WIDTH);
    let height = parseInt(HEIGHT);

    MODELS = new ModelList(function(i, model) {
        $('div#model-pane').append(`
            <div id="model-${i}" class="item">
                <label>${i}:</label>
                <input id="model-select-${i}" name="models" class="select" type="radio" />
                <label for="model-select-${i}">${model.getName()}</label>
                <input id="model-hide-${i}" name="models" type="checkbox" />
                <label for="model-hide-${i}"><i class="fas fa-eye-slash"></i></label>
                <button class="remove"><i class="fas fa-times"></i></button>
            </div>
        `);

        let selector = $(`#model-select-${i}`);
        selector.on('change', function(e) {
            if ($(e.target).prop('checked'))
                select_model(gl, i);
        });
        selector.prop('checked', true).change();

        $(`#model-hide-${i}`).on('change', function(e) {
            MODELS.at(i).visible(! $(e.target).prop('checked'));
            render(gl);
        });

        let controls = $(`div#model-${i}`);
        controls.children('.remove').click(function() {
            if (SELECTED === i)
                select_model(gl, null);

            controls.remove();
            MODELS.remove(i);
            render(gl);
        });
    });
    select_model(gl, null);

    // {
    //     let sphere   = (new Sphere(ORIGIN, 100)).toTriangles(50, 50);
    //     let mySphere = new Model('My Sphere 1', sphere.indices, sphere.vertices, {
    //         color:   new RGBColor(0.2, 0.2, 1.0),
    //         shaders: Sphere.SHADERS,
    //         normals: Sphere.NORMALS
    //     });

    //     MODELS.insert(mySphere);
    // }
    // {
    //     let sphere   = (new Sphere(ORIGIN, 40)).toTriangles(50, 50);
    //     let mySphere = new Model('My Sphere 2', sphere.indices, sphere.vertices, {
    //         color:   new RGBColor(0.2, 1.0, 0.2),
    //         shaders: Sphere.SHADERS,
    //         normals: Sphere.NORMALS
    //     });
    //     mySphere.setTranslateX(200);

    //     MODELS.insert(mySphere);
    // }
    {
        // let cube   = (new Cube(ORIGIN, 50)).toTriangles();
        let cube   = (new Cube(ORIGIN, 150)).toTriangles();
        let myCube = new Model('My Cube 1', cube.indices, cube.vertices, {
            color:   new RGBColor(1.0, 0.2, 0.2),
            shaders: Cube.SHADERS,
            normals: Cube.NORMALS
        });
        myCube.setRotateY(60);
        myCube.setScaleY(1.8);
        // myCube.setTranslateX(125);
        // myCube.setTranslateY(100);

        MODELS.insert(myCube);
    }

    CANVAS.mousedown(function(e) {
        switch (e.which) {
        case 1:
            let mouse  = get_mouse_xy(CANVAS, e);
            let result = new Uint8Array(4);

#ifdef VERBOSE
            gl.readPixels(mouse.x, mouse.y, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, result);
            log('Clicked pixel color:', result);
#endif

            picking_render(gl);
            gl.readPixels(mouse.x, mouse.y, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, result);

#ifdef VERBOSE
            log('Alpha-picking pixel color:', result);
#endif

            let i = 255 - (result[3] + 1);
            if (i < 0) {
                $('form#models input.select').prop('checked', false);
                select_model(gl, null);
            } else {
                $(`#model-select-${i}`).prop('checked', true).change();
            }
            break;
        }
    });

    CANVAS.mousemove(function(e) {
        let mouse  = get_mouse_xy(CANVAS, e);
        let result = new Uint8Array(4);

        picking_render(gl);
        gl.readPixels(mouse.x, mouse.y, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, result);

        let i = 255 - (result[3] + 1);
        if (i < 0) {
            FOCUSED = null;
        } else {
#ifdef VERBOSE
            if (FOCUSED != i)
                log('Focused model:', i);
#endif
            FOCUSED = i;
        }
        render(gl);
    });

    $(document).on('keydown', function(e) {
        if ($(e.target).is('input'))
            return;
        
#ifdef VERBOSE
        log('Received keypress:', e.keyCode, '==>', RKEYS[e.keyCode]);
#endif

        switch (e.keyCode) {
        case KEYS.y:
            CAMERA.yaw(Radians.fromDegrees( 5));
            break;
        case KEYS.u:
            CAMERA.yaw(Radians.fromDegrees(-5));
            break;

        case KEYS.g:
            CAMERA.roll(Radians.fromDegrees( 5));
            break;
        case KEYS.h:
            CAMERA.roll(Radians.fromDegrees(-5));
            break;

        case KEYS.i:
            PERSPECTIVE_FOVY -= 5;
            log('Changed FOV to:', PERSPECTIVE_FOVY);
            break;
        case KEYS.o:
            PERSPECTIVE_FOVY += 5;
            log('Changed FOV to:', PERSPECTIVE_FOVY);
            break;

        case KEYS.j:
            CAMERA.moveForward(20);
            break;
        case KEYS.k:
            CAMERA.moveBackward(20);
            break;

        case KEYS.LEFT:
            CAMERA.moveLeft(10);
            break;
        case KEYS.RIGHT:
            CAMERA.moveRight(10);
            break;

        case KEYS.UP:
            CAMERA.moveUp(10);
            break;
        case KEYS.DOWN:
            CAMERA.moveDown(10);
            break;
        }

        render(gl);
    });

    init_angle_slider(GETTER_SETTER(ROTATE_X), 'rotate-world-x', RENDER);
    init_angle_slider(GETTER_SETTER(ROTATE_Y), 'rotate-world-y', RENDER);
    init_angle_slider(GETTER_SETTER(ROTATE_Z), 'rotate-world-z', RENDER);

    init_space_slider(width,  GETTER_SETTER(TRANSLATE_X), 'translate-world-x', RENDER);
    init_space_slider(height, GETTER_SETTER(TRANSLATE_Y), 'translate-world-y', RENDER);
    init_space_slider(DEPTH,  GETTER_SETTER(TRANSLATE_Z), 'translate-world-z', RENDER);

    $('#' + PROJECTION).prop('checked', true);
    $('form#projection input[name=projection]').on('change', function(e) {
        let elem   = $(e.target);
        PROJECTION = elem.attr('id');
        render(gl);
    });

    init_color_picker(GETTER_SETTER(AMBIANT_COLOR), 'light-ambiant-color', RENDER);

    init_direc_slider(GETTER_SETTER(DIRECT_X), 'light-direct-x', RENDER);
    init_direc_slider(GETTER_SETTER(DIRECT_Y), 'light-direct-y', RENDER);
    init_direc_slider(GETTER_SETTER(DIRECT_Z), 'light-direct-z', RENDER);

    init_color_picker(GETTER_SETTER(DIRECT_COLOR), 'light-direct-color', RENDER);

    init_space_slider(width,  GETTER_SETTER(POINT_X), 'light-point-x', RENDER);
    init_space_slider(height, GETTER_SETTER(POINT_Y), 'light-point-y', RENDER);
    init_space_slider(DEPTH,  GETTER_SETTER(POINT_Z), 'light-point-z', RENDER);

    init_color_picker(GETTER_SETTER(POINT_COLOR), 'light-point-color', RENDER);

    $('#' + light.AMBIANT).prop('checked', LIGHT.ambiant);
    $('#' + light.AMBIANT).on('change', function(e) {
        LIGHT.ambiant = $(e.target).prop('checked');
        render(gl);
    });

    $('#' + light.DIRECT).prop('checked', LIGHT.direct);
    $('#' + light.DIRECT).on('change', function(e) {
        LIGHT.direct = $(e.target).prop('checked');
        render(gl);
    });

    $('#' + light.POINT).prop('checked', LIGHT.point);
    $('#' + light.POINT).on('change', function(e) {
        LIGHT.point = $(e.target).prop('checked');
        render(gl);
    });

    init_range({
        id: 'light-specular-power',
        value: SPECULAR_POWER,
        min: 2,
        max: 128,
        step: 2,

        parse: function(value) {
            SPECULAR_POWER = parseInt(value);
            value          = SPECULAR_POWER.toString();
            switch (value.length) {
            case 1:
                value = '00' + value;
                break;
            case 2:
                value =  '0' + value;
                break;
            }
            return value;
        },

        update: function() {
            render(gl);
        }
    });

    $('#' + light.SPECULAR).prop('checked', LIGHT.specular);
    $('#' + light.SPECULAR).on('change', function(e) {
        LIGHT.specular = $(e.target).prop('checked');
        render(gl);
    });

    $('#' + SHADING).prop('checked', true);
    $('form#shading-type input[name=shading-type]').on('change', function(e) {
        let elem = $(e.target);
        SHADING  = elem.attr('id');
        render(gl);
    });

    $('#' + SHAPE).prop('checked', true);
    $('form#shape-type input[name=shape-type]').on('change', function(e) {
        let elem = $(e.target);
        SHAPE    = elem.attr('id');
        render(gl);
    });

    $('#animate-rotate-about').click(function() {
#ifdef VERBOSE
            log('Animating...');
#endif
        begin_animation('animate-rotate-about');
        setTimeout(function() {
            end_animation('animate-rotate-about');
        }, 2000);
    });
    $('#animate-shake').click(function() {
#ifdef VERBOSE
            log('Animating...');
#endif
        begin_animation('animate-shake');
        setTimeout(function() {
            end_animation('animate-shake');
        }, 2000);
    });
    $('#animate-stretch').click(function() {
#ifdef VERBOSE
            log('Animating...');
#endif
        begin_animation('animate-stretch');
        setTimeout(function() {
            end_animation('animate-stretch');
        }, 2000);
    });

    render(gl);
}

function select_model(gl, i) {
    const SCALE = 5;

    if (i < 0)
        i = null;
    SELECTED = i;

    log('Selected model:', SELECTED);

    let width  = parseInt(WIDTH);
    let height = parseInt(HEIGHT);
    if (i === null) {
        init_angle_slider(CONST(0), 'rotate-model-x', VOID);
        init_angle_slider(CONST(0), 'rotate-model-y', VOID);
        init_angle_slider(CONST(0), 'rotate-model-z', VOID);

        init_space_slider(width,  CONST(0), 'translate-model-x', VOID);
        init_space_slider(height, CONST(0), 'translate-model-y', VOID);
        init_space_slider(DEPTH,  CONST(0), 'translate-model-z', VOID);
        
        init_scale_slider(SCALE, CONST(1), 'scale-model-x', VOID);
        init_scale_slider(SCALE, CONST(1), 'scale-model-y', VOID);
        init_scale_slider(SCALE, CONST(1), 'scale-model-z', VOID);

        $('div#editor input[type=range]').prop('disabled', true);
    } else {
        let model_angle_slider = function(getterName, setterName, sliderID) {
            init_angle_slider(function(value) {
                let model = MODELS.at(i);

                if (value !== undefined) {
                    model[setterName](value);
                } else {
                    return model[getterName]();
                }
            }, sliderID, RENDER);
        };

        let model_space_slider = function(delta, getterName, setterName, sliderID) {
            init_space_slider(delta, function(value) {
                let model = MODELS.at(i);

                if (value !== undefined) {
                    model[setterName](value);
                } else {
                    return model[getterName]();
                }
            }, sliderID, RENDER);
        };

        let model_scale_slider = function(getterName, setterName, sliderID) {
            init_scale_slider(SCALE, function(value) {
                let model = MODELS.at(i);

                if (value !== undefined) {
                    model[setterName](value);
                } else {
                    return model[getterName]();
                }
            }, sliderID, RENDER);
        };

        model_angle_slider('getRotateX', 'setRotateX', 'rotate-model-x');
        model_angle_slider('getRotateY', 'setRotateY', 'rotate-model-y');
        model_angle_slider('getRotateZ', 'setRotateZ', 'rotate-model-z');

        model_space_slider(width,  'getTranslateX', 'setTranslateX', 'translate-model-x');
        model_space_slider(height, 'getTranslateY', 'setTranslateY', 'translate-model-y');
        model_space_slider(DEPTH,  'getTranslateZ', 'setTranslateZ', 'translate-model-z');

        model_scale_slider('getScaleX', 'setScaleX', 'scale-model-x');
        model_scale_slider('getScaleY', 'setScaleY', 'scale-model-y');
        model_scale_slider('getScaleZ', 'setScaleZ', 'scale-model-z');
    }
    render(gl);
}

function init_angle_slider(var_fn, range_id, render_fn) {
    init_range({
        id: range_id,
        value: var_fn(),
        min: -180,
        max: 180,
        step: 10,

        parse: function(value) {
            var_fn(parseInt(value));
            value = Math.abs(var_fn()).toString();
            switch (value.length) {
            case 1:
                value = '00' + value;
                break;
            case 2:
                value =  '0' + value;
                break;
            }
            if (var_fn() >= 0)
                value = '+' + value;
            else
                value = '-' + value;
            return value;
        },

        update: function() {
            render_fn();
        }
    });
}

function init_space_slider(delta, var_fn, range_id, render_fn) {
    init_range({
        id: range_id,
        value: var_fn(),
        min: -delta,
        max: delta,
        step: 5,

        parse: function(value) {
            var_fn(parseInt(value));
            value = Math.abs(var_fn()).toString();
            switch (value.length) {
            case 1:
                value = '00' + value;
                break;
            case 2:
                value =  '0' + value;
                break;
            }
            if (var_fn() >= 0)
                value = '+' + value;
            else
                value = '-' + value;
            return value;
        },

        update: function() {
            render_fn();
        }
    });
}

function init_scale_slider(delta, var_fn, range_id, render_fn) {
    init_range({
        id: range_id,
        value: var_fn(),
        min: 0,
        max: delta,
        step: 0.05,

        parse: function(value) {
            var_fn(parseFloat(value));
            return Math.abs(var_fn()).toFixed(2);
        },

        update: function() {
            render_fn();
        }
    });
}

function init_direc_slider(var_fn, range_id, render_fn) {
    init_range({
        id: range_id,
        value: var_fn(),
        min: -100,
        max: 100,
        step: 1,

        parse: function(value) {
            var_fn(parseInt(value));
            value = Math.abs(var_fn()).toString();
            switch (value.length) {
            case 1:
                value = '00' + value;
                break;
            case 2:
                value =  '0' + value;
                break;
            }
            if (var_fn() >= 0)
                value = '+' + value;
            else
                value = '-' + value;
            return value;
        },

        update: function() {
            render_fn();
        }
    });
}


function render(gl) {
    clear(gl, COLOR);

    let world = new Matrix();
    world     = world.rotateX(Radians.fromDegrees(ROTATE_X));
    world     = world.rotateY(Radians.fromDegrees(ROTATE_Y));
    world     = world.rotateZ(Radians.fromDegrees(ROTATE_Z));
    {
        let vec = new Vector(TRANSLATE_X, TRANSLATE_Y, TRANSLATE_Z);
        world   = world.translate(vec);
    }

    let view = CAMERA.getView();

    let width  = parseInt(WIDTH);
    let height = parseInt(HEIGHT);
    let proj;

    switch (PROJECTION) {
    case projection.ORTHOGRAPHIC:
        proj = Matrix.ortho({
            left: -(width / 2),
            right: width / 2,
            bottom: -(height / 2),
            top: height / 2,
            near: 1,
            far: 1000
        });
        break;
    case projection.PERSPECTIVE:
        proj = Matrix.perspective({
            fovy: Radians.fromDegrees(PERSPECTIVE_FOVY),
            aspect: width / height,
            near: 1,
            far: 1000
        });
        break;
    }

    let lights = {};

    if (LIGHT.ambiant)
        lights.ambiant  = new AmbiantLight(AMBIANT_COLOR);
    else
        lights.ambiant  = null;

    if (LIGHT.direct)
        lights.direct   = new DirectLight(new Vector(DIRECT_X, DIRECT_Y, DIRECT_Z),
                                         DIRECT_COLOR);
    else
        lights.direct   = null;

    lights.point        = new PointLight(new Vector(POINT_X, POINT_Y, POINT_Z),
                                        POINT_COLOR);
    if (! LIGHT.point)
        lights.point.setOn(false);

    if (LIGHT.specular)
        lights.specular = new SpecularLight(SPECULAR_POWER);
    else
        lights.specular = null;

    if (SHOW_POINT) {
        let point      = new Sphere(lights.point.getPosition(), 15);
        point          = point.toTriangles(50, 50);
        let pointLight = new Model('Point Light', point.indices, point.vertices, {
            color: lights.point.getColor()
        });
        render_model(gl, pointLight, world, CAMERA, proj, {
            ambiant:  new AmbiantLight(TRUE_WHITE),
            direct:   null,
            point:    null,
            specular: null
        });
    }

    MODELS.mapVisible(function(i, model) {
        let color = model.getColor();

        switch (SHADING) {
        case shading.MODEL:
            render_model(gl, model, world, CAMERA, proj, lights);
            break;
        case shading.FLAT:
            render_flat(gl, model, color, world, CAMERA, proj, lights);
            break;
        case shading.GOURAUD:
            render_gouraud(gl, model, color, world, CAMERA, proj, lights);
            break;
        case shading.PHONG:
            render_phong(gl, model, color, world, CAMERA, proj, lights);
            break;
        case shading.NORMAL:
            render_normal(gl, model, world, view, proj);
            break;
        case shading.DEPTH:
            render_depth(gl, model, color, world, view, proj, 250, 50);
            break;
        case shading.EDGE:
            render_edge(gl, model, TRUE_BLACK, color, 1/2, world, view, proj);
            break;
        case shading.EDGE_SELECTION:
            render_edge_selection(gl, i, model, color, world, view, proj);
            break;
        }
    });
}

function render_edge_selection(gl, i, model, color, world, view, projection) {
    color = color.scale(0.5);

    let selectedColor = WHITE.scale(0.8);
    let focusedColor  = selectedColor.scale(0.8);

    if (i === SELECTED) {
        render_edge(gl, model, color, selectedColor, 1/2, world, view, projection);
    } else if (i === FOCUSED) {
        render_edge(gl, model, color, focusedColor, 1/8, world, view, projection);
    } else {
        render_edge(gl, model, color, TRUE_BLACK, 0, world, view, projection);
    }
}

function picking_render(gl) {
    clear(gl, TRUE_BLACK);

    let world = new Matrix();
    world     = world.rotateX(Radians.fromDegrees(ROTATE_X));
    world     = world.rotateY(Radians.fromDegrees(ROTATE_Y));
    world     = world.rotateZ(Radians.fromDegrees(ROTATE_Z));
    {
        let vec = new Vector(TRANSLATE_X, TRANSLATE_Y, TRANSLATE_Z);
        world   = world.translate(vec);
    }

    let view = CAMERA.getView();

    let width  = parseInt(WIDTH);
    let height = parseInt(HEIGHT);
    let proj;

    switch (PROJECTION) {
    case projection.ORTHOGRAPHIC:
        proj = Matrix.ortho({
            left: -(width / 2),
            right: width / 2,
            bottom: -(height / 2),
            top: height / 2,
            near: 1,
            far: 1000
        });
        break;
    case projection.PERSPECTIVE:
        proj = Matrix.perspective({
            fovy: Radians.fromDegrees(PERSPECTIVE_FOVY),
            aspect: width / height,
            near: 1,
            far: 1000
        });
        break;
    }

    let lights = {
        ambiant:  null,
        direct:   null,
        point:    null,
        specular: null
    };

    MODELS.mapVisible(function(i, model) {
        let color = TRUE_BLACK.copy().setAlpha((255 - (i + 1)) / 255);
        render_flat(gl, model, color, world, CAMERA, proj, lights);
    });
}
